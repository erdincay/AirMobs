package edu.mit.media.airmobs;

import java.nio.channels.ClosedByInterruptException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import android.app.ActivityManager;
import android.app.ActivityManager.RunningTaskInfo;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.RemoteException;
import android.util.Log;


/**
 * 
 * @author maksim
 *
 * purpose and rational:
 * start after boot runs all the other services as needed
 * monitor the state of the networks 
 * decide when to register (or unregister) all the intent handlers
 * content provider for all the airmobs data logged
 * 
 * MonitorService is a service that runs a thread that monitors the phone state 
 * and decides the Airmobs rules to be executed such as publishing a network
 * when 3G is connected and WiFi is free for tethered use or looking for a network 
 * when 3G is not connected and there is no open/preferred network
 *
 */

public class MonitorService extends ServiceAdapter {

	public enum AirmobsRole { PROVIDER, CUSTOMER, IDLE }
	/**
	 * Implements the API class provisioning method required by the ServiceAdapter helper class
	 * Api class is defined by the aidl interface MonitorApi
	 * The returned implementation of the as Stub class (generated by the aidl compiler) 
	 * This method invoked by the service adapter once a client application has successfully
	 * bound to the service from onBound method 
	 * @see edu.mit.media.airmobs.ServiceAdapter#getApiObject()
	 * @see android.app.Service#onBind(android.content.Intent)
	 */
	@Override
	IBinder getApiObject() {
		Log.i(LOG_TAG,"api object requested ...");
		// TODO create and return Api Object
		return monitorApi;
	}

	/**
	 * Provide the notification to be displayed in the notification area
	 * required by the ServiceAdapter helper class 
	 */
	@Override
	String getNotificationText() {
		// TODO Auto-generated method stub
		return "Network and UI events monitoring service";
	}
	/**
	 * Called after the service is created by the ServiceAdapter helper class 
	 */
	@Override
	void created() {
		// TODO Auto-generated method stub
		Log.i(LOG_TAG,"created ...");
		mMonitoring = new Thread(new Monitor());
		service_running = true;
		mState = AirmobsRole.IDLE;
		mMonitoring.start();
		counter = 0;
		mListeners = new ArrayList<MonitorListener>();
		mServerLogic = new ServerLogic();
		mListeners.add(mServerLogic);
	}
	/**
	 * Called after service is destroyed by the ServiceAdapter helper class
	 */
	void destroyed(){
		if (service_running){
			service_running = false;
			mMonitoring.interrupt();
		}
		Log.i(LOG_TAG,"closing thread and exiting service");
	}
	
	/**
	 * object implementing the aidl api class 
	 */
	private final MonitorApi.Stub monitorApi = new MonitorApi.Stub() {
		
		@Override
		public int getStatus() throws RemoteException {
			Log.i(LOG_TAG,"status request returning counter = "+Integer.toString(counter));
			return counter;
		}
		
		@Override
		public boolean exit() throws RemoteException {
			service_running = false;
			return true;
		}

		@Override
		public void test(int test_case) throws RemoteException {
			// send event for all monitor listeners to set role as network provider
			if (test_case == 1) {
				Iterator<MonitorListener> it = mListeners.iterator();
				while (it.hasNext()){
					it.next().monitorRoleProvider();
					mState = AirmobsRole.PROVIDER;
				}
			}
			// send event for all monitor listeners to set role as network customer
			if (test_case == 2) {
				Iterator<MonitorListener> it = mListeners.iterator();
				while (it.hasNext()){
					it.next().monitorRoleCustomer();
					mState = AirmobsRole.CUSTOMER;
				}
			}
			// send event for all monitor listeners to set role as network customer
			if (test_case == 3) {
				Iterator<MonitorListener> it = mListeners.iterator();
				while (it.hasNext()){
					it.next().monitorRoleIdle();
					mState = AirmobsRole.IDLE;
				}
			}
		}

		@Override
		public void addMonitorListener(MonitorListener handler)
				throws RemoteException {
			if (!mListeners.contains(handler))
				mListeners.add(handler);	
		}

		@Override
		public void removeMonitorListener(MonitorListener handler)
				throws RemoteException {
			if (mListeners.contains(handler))
				mListeners.remove(handler);	
			}
	};
	/**
	 * The internal Monitor class implemented as a thread
	 * 
	 *
	 */
	private class Monitor implements Runnable {

		@Override
		public void run() {
			try {
				while (service_running){
					Thread.sleep(1000);
					counter++;
					Log.i(LOG_TAG,"monitor hitting "+Integer.toString(counter));					
					// understanding my role
					// notifying my listeners on the role decided  --> simulated by api.test(int)
					//
					if (mState == AirmobsRole.CUSTOMER){
						if (isMessagingActivated()) {
							Log.i(LOG_TAG, "detected messaging app activated --> starting AirmobsSmsSender");
							Intent msgui = new Intent(MonitorService.this,AirmobsSmsSender.class);
						    msgui.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
							MonitorService.this.startActivity(msgui);
						}
					}
				}				
			}
			catch (Exception e){
				if (e instanceof ClosedByInterruptException){
					service_running = false;
					Log.i(LOG_TAG,"closing monitor thread - got external interrupt");
				}
			}
		}
		
	}
	
	/**
	 * monitors whether user has activated messaging - hijack ui
	 */
	private boolean isMessagingActivated(){
		boolean messaging_activated = false;
		ActivityManager am = (ActivityManager) MonitorService.this.getSystemService(Context.ACTIVITY_SERVICE);
        List<RunningTaskInfo> tasks = am.getRunningTasks(1);
        if (!tasks.isEmpty()) {
            ComponentName topActivity = tasks.get(0).topActivity;
            if (topActivity.getClassName().contains("com.android.mms.ui")) {
                messaging_activated = true;
            }
        }
        
        return messaging_activated;
	}
	
	
	private int counter;
	private boolean service_running;
	private Thread mMonitoring;
	private MonitorService.AirmobsRole mState;
	private static final String LOG_TAG = "Airmobs::MonitorService";
	private ArrayList<MonitorListener> mListeners;
	private ServerLogic mServerLogic;;

}
