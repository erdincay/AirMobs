package edu.mit.media.airmobs;

import java.nio.channels.ClosedByInterruptException;

import android.os.IBinder;
import android.os.RemoteException;
import android.util.Log;


/**
 * 
 * @author maksim
 *
 * purpose and rational:
 * start after boot runs all the other services as needed
 * monitor the state of the networks 
 * decide when to register (or unregister) all the intent handlers
 * content provider for all the airmobs data logged
 * 
 * MonitorService is a service that runs a thread that monitors the phone state 
 * and decides the Airmobs rules to be executed such as publishing a network
 * when 3G is connected and WiFi is free for tethered use or looking for a network 
 * when 3G is not connected and there is no open/preferred network
 *
 */

public class MonitorService extends ServiceAdapter {

	/**
	 * Implements the API class provisioning method required by the ServiceAdapter helper class
	 * Api class is defined by the aidl interface MonitorApi
	 * The returned implementation of the as Stub class (generated by the aidl compiler) 
	 * This method invoked by the service adapter once a client application has successfully
	 * bound to the service from onBound method 
	 * @see edu.mit.media.airmobs.ServiceAdapter#getApiObject()
	 * @see android.app.Service#onBind(android.content.Intent)
	 */
	@Override
	IBinder getApiObject() {
		Log.i(LOG_TAG,"api object requested ...");
		// TODO create and return Api Object
		return monitorApi;
	}

	/**
	 * Provide the notification to be displayed in the notification area
	 * required by the ServiceAdapter helper class 
	 */
	@Override
	String getNotificationText() {
		// TODO Auto-generated method stub
		return "Network and UI events monitoring service";
	}
	/**
	 * Called after the service is created by the ServiceAdapter helper class 
	 */
	@Override
	void created() {
		// TODO Auto-generated method stub
		Log.i(LOG_TAG,"created ...");
		mMonitoring = new Thread(new Monitor());
		service_running = true;
		mMonitoring.start();
		counter = 0;
		
	}
	/**
	 * Called after service is destroyed by the ServiceAdapter helper class
	 */
	void destroyed(){
		if (service_running){
			service_running = false;
			mMonitoring.interrupt();
		}
		Log.i(LOG_TAG,"closing thread and exiting service");
	}
	
	/**
	 * object implementing the aidl api class 
	 */
	private final MonitorApi.Stub monitorApi = new MonitorApi.Stub() {
		
		@Override
		public int getStatus() throws RemoteException {
			Log.i(LOG_TAG,"status request returning counter = "+Integer.toString(counter));
			return counter;
		}
		
		@Override
		public boolean exit() throws RemoteException {
			service_running = false;
			return true;
		}
	};
	/**
	 * The internal Monitor class implemented as a thread
	 * 
	 *
	 */
	private class Monitor implements Runnable {

		@Override
		public void run() {
			try {
				while (service_running){
					Thread.sleep(100);
					counter++;
					Log.i(LOG_TAG,"monitor hitting "+Integer.toString(counter));
				}				
			}
			catch (Exception e){
				if (e instanceof ClosedByInterruptException){
					service_running = false;
					Log.i(LOG_TAG,"closing monitor thread - got external interrupt");
				}
			}
		}
		
	}
	
	private int counter;
	private boolean service_running;
	private Thread mMonitoring;
	private static final String LOG_TAG = "Airmobs::MonitorService";

}
